import { DisposableDelegate } from '@phosphor/disposable';
import { Widget } from '@phosphor/widgets';
import { PageConfig } from '@jupyterlab/coreutils';
import { showDialog, showErrorMessage, Dialog, ToolbarButton } from '@jupyterlab/apputils';
import * as offline from "./offlinenotebook";
import $ from "jquery";
/**
 * The plugin registration information.
 */
const extension = {
    activate,
    id: 'offlinenotebook:offlineNotebookButtons',
    autoStart: true
};
/**
 * A notebook widget extension that adds a button to the toolbar.
 */
export class OfflineNotebookButtons {
    /**
     * Create a new extension object.
     */
    createNew(panel, context) {
        // https://stackoverflow.com/a/40679225
        // For debugging in browser console assign panel to a global var
        // eval("window.jlpanel = panel;");
        // https://jupyterlab.github.io/jupyterlab/apputils/classes/toolbarbutton.html
        // https://jupyterlab.github.io/jupyterlab/apputils/interfaces/toolbarbuttoncomponent.iprops.html
        let buttons = [];
        buttons.push(['downloadVisible', new ToolbarButton({
                className: 'downloadVisible',
                iconClassName: 'fa fa-download',
                onClick: () => {
                    downloadNotebookFromBrowser(panel);
                },
                tooltip: 'Download visible',
                label: 'Download'
            })]);
        if (offline.repoid()) {
            buttons.push(['saveToBrowser', new ToolbarButton({
                    className: 'saveToBrowser',
                    iconClassName: 'fa fa-cloud-download',
                    onClick: () => {
                        localstoreSaveNotebook(panel);
                    },
                    tooltip: 'Save to browser storage'
                })]);
            buttons.push(['loadFromBrowser', new ToolbarButton({
                    className: 'loadFromBrowser',
                    iconClassName: 'fa fa-cloud-upload',
                    onClick: () => {
                        localstoreLoadNotebook(panel);
                    },
                    tooltip: 'Restore from browser storage'
                })]);
        }
        if (offline.binderRefUrl()) {
            let repoIcons = {
                'GitHub': 'fa fa-github',
                'GitLab': 'fa fa-gitlab',
                'Git': 'fa fa-git'
            };
            buttons.push(['openRepo', new ToolbarButton({
                    className: 'openRepo',
                    iconClassName: repoIcons[offline.repoLabel()] || 'fa-external-link',
                    onClick: offline.openBinderRepo,
                    tooltip: 'Visit Binder repository',
                    label: offline.repoLabel()
                })]);
        }
        if (offline.binderPersistentUrl()) {
            buttons.push(['linkToBinder', new ToolbarButton({
                    className: 'linkToBinder',
                    iconClassName: 'fa fa-link',
                    onClick: () => {
                        showBinderLink(panel);
                    },
                    tooltip: 'Link to this Binder',
                    label: 'Binder'
                })]);
        }
        buttons.reverse();
        buttons.forEach(item => {
            panel.toolbar.insertItem(9, item[0], item[1]);
        });
        return new DisposableDelegate(() => {
            buttons.forEach(item => {
                item[1].dispose();
            });
        });
    }
}
function formatRepoPathforDialog(path) {
    return 'repoid: ' + offline.repoid() + ' path: ' + path;
}
// function getNotebookFromBrowser(): null {
//   return Jupyter.notebook.toJSON();
// }
function localstoreSaveNotebook(panel) {
    var path = panel.context.path;
    var nb = panel.content.model.toJSON();
    var repopathDisplay = formatRepoPathforDialog(path);
    offline.saveNotebook(path, nb, function (key) {
        console.log('offline-notebook saved: ', key);
        return showDialog({
            title: 'Notebook saved to browser storage',
            body: repopathDisplay,
            buttons: [Dialog.okButton()]
        });
    }, (e) => {
        showErrorMessage('Local storage IndexedDB error', e);
        throw (e);
    });
}
// Workround error in nb['contents']
// Element implicitly has an 'any' type because expression of type '"contents"' can't be used to index type 'string | number | true | JSONObject | JSONArray'.
// Property 'contents' does not exist on type 'string | number | true | JSONObject | JSONArray'.ts(7053)
// https://dev.to/kingdaro/indexing-objects-in-typescript-1cgi
function hasKey(obj, key) {
    return key in obj;
}
function localstoreLoadNotebook(panel) {
    var path = panel.context.path;
    var repopathDisplay = formatRepoPathforDialog(path);
    var key = 'repoid:' + offline.repoid() + ' path:' + path;
    offline.loadNotebook(path, (nb) => {
        if (nb) {
            console.log('offline-notebook found ' + key);
            return showDialog({
                title: 'This will replace your current notebook with',
                body: repopathDisplay,
                buttons: [Dialog.cancelButton(), Dialog.warnButton({ label: 'OK' })]
            }).then(result => {
                const contentsKey = 'content';
                if (result.button.accept && !panel.context.isDisposed) {
                    if (hasKey(nb, contentsKey)) {
                        panel.context.model.fromJSON(nb[contentsKey]);
                    }
                    else {
                        showErrorMessage('Invalid notebook', '"content" not found');
                    }
                }
            });
        }
        else {
            console.log('offline-notebook not found ' + key);
            showErrorMessage('Notebook not found in browser storage', key);
        }
    }, (e) => {
        showErrorMessage('Local storage IndexedDB error', e);
        throw (e);
    });
}
function downloadNotebookFromBrowser(panel) {
    var name = panel.context.path.replace(/.*\//, '');
    var nb = panel.content.model.toJSON();
    offline.downloadNotebookFromBrowser(name, nb);
}
class CopyShareURLWidget extends Widget {
    constructor(binderUrl) {
        super({ node: createCopyShareURLNode(binderUrl) });
    }
}
// https://github.com/jupyterhub/binderhub/blob/b32ad4425be3319f7a2c59cf8253e979512b955d/examples/appendix/static/custom.js#L1-L7
function copy_link_into_clipboard(b) {
    var $temp = $("<input>");
    $(b).parent().append($temp);
    $temp.val($(b).data('url')).select();
    document.execCommand("copy");
    $temp.remove();
}
function createCopyShareURLNode(binderUrl) {
    var body = $('<div/>', {
        'style': 'flex-direction: row;',
        'data-url': binderUrl
    }).append($('<pre/>', {
        'text': binderUrl,
        'style': 'margin: 0; white-space: pre-wrap; word-break: break-all;'
    }));
    var button = $('<button/>', {
        'title': 'Copy binder link to clipboard',
        'data-url': binderUrl
    }).click(function () {
        copy_link_into_clipboard(button);
    });
    button.append($('<i/>', {
        'class': 'fa fa-clipboard'
    }));
    body.append(button);
    // Unwrap JQuery object
    return body.get(0);
}
// TODO: Format link and copy it
function showBinderLink(panel) {
    var path = panel.context.path;
    var binderUrl = offline.binderPersistentUrl() + '?urlpath=' + encodeURIComponent('lab/tree/' + path);
    // Note adding a copy button here doesn't work, perhaps because the event goes
    // through too many steps (firefox only allows "copy" on certain actions)
    return showDialog({
        title: 'Share Binder link',
        body: new CopyShareURLWidget(binderUrl),
        buttons: [Dialog.okButton()]
    });
}
/**
 * Activate the extension.
 */
function activate(app) {
    console.log('Activating jupyter-offlinenotebook JupyterLab extension');
    const baseUrl = PageConfig.getBaseUrl();
    $.getJSON(baseUrl + 'offlinenotebook/config', function (data) {
        offline.initialise(data);
        // addButtons();
    });
    app.docRegistry.addWidgetExtension('Notebook', new OfflineNotebookButtons());
}
;
/**
 * Export the extension as default.
 */
export default extension;
//# sourceMappingURL=index.js.map